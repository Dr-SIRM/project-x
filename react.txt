import React, { createContext, useContext, useEffect, useState } from 'react';
import { useNavigate  } from 'react-router-dom';

export const AuthContext = createContext();

const AuthProvider = ({ children }) => {
  const navigate = useNavigate();
  const [user, setUser] = useState(null);
  const [error, setError] = useState('');

  const login = async (email, password) => {
    try {
      console.log('Email:', email, 'Password:', password);
      const response = await fetch("http://localhost:5000/api/login", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ email, password }),
      });
      if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      console.log('Server response:', data);
      setUser( data.user );
      localStorage.setItem('session_token', data.session_token);
      localStorage.setItem('user', JSON.stringify(data.user));
  } catch (error) {
    setError('Invalid email or password');
  }
};

  useEffect(() => {
    if (user) {
      console.log('User after login:', user);
      console.log('Session token after login:', localStorage.getItem('session_token'));
      navigate('/dashboard');
    } else {
      console.log('Back to Login');
    }  
  }, [user]); // This useEffect hook logs the value of 'user' whenever it changes

  const logout = () => {
    // Clear user data and access token from localStorage
    setUser(null);
    localStorage.removeItem('session_token');
    localStorage.removeItem('user');
    navigate('/login');
  };

  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export default AuthProvider;









import React, { useContext } from 'react';
import { Route, Navigate } from 'react-router-dom';
import { AuthContext } from './AuthContext';

const PrivateRoute = ({ component: Component, accessLevel, ...rest }) => {
  const { user } = useContext(AuthContext);

  console.log('User in PrivateRoute:', user); // Print the user state
  console.log('Session token in PrivateRoute:', localStorage.getItem('session_token'));

  if (!user) {
    console.log('User not authenticated in PrivateRoute');
    return <Navigate to="/login" />; // Redirect to login if user is not authenticated
  }

  if (user.access_level !== accessLevel) {
    return <Navigate to="/login" />; // Redirect to unauthorized page if user's access level is not sufficient
  }

  return <Component {...rest} />;
};

export default PrivateRoute;










import { useState, useEffect, useContext } from "react";
import { lazy, Suspense } from 'react';
import { BrowserRouter as Router, Routes, Route, Outlet } from "react-router-dom";
import { useLocation, Navigate } from "react-router-dom";
import { createBrowserHistory } from "history";
import AuthProvider from "./AuthContext";
import PrivateRoute from "./PrivateRoute";
import Topbar from "./scenes/global/Topbar";
import Sidebar from "./scenes/global/Sidebar";
import Login from "./scenes/login";
import Dashboard from "./scenes/dashboard";
import Team from "./scenes/team";
import Availability from "./scenes/availability";
import Update from "./scenes/update";
import Invite from "./scenes/invite";
import Invoices from "./scenes/invoices";
import Contacts from "./scenes/contacts";
import Company from "./scenes/company";
import Bar from "./scenes/bar";
import Form from "./scenes/form";
import Line from "./scenes/line";
import Pie from "./scenes/pie";
import FAQ from "./scenes/faq";
import Plan from "./scenes/plan";

import Geography from "./scenes/geography";
import { CssBaseline, ThemeProvider } from "@mui/material";
import { ColorModeContext, useMode } from "./theme";
import Calendar from "./scenes/calendar";
import axios from "axios";
import { AuthContext } from "./AuthContext";


function App() {
  const [theme, colorMode] = useMode();
  const [isSidebar, setIsSidebar] = useState(true);
  const [users, setUsers] = useState([]);
  const [message, setMessage] = useState("");
  const location = useLocation();
  const isAuthenticated = location.pathname !== "/"; // Check if the user is authenticated
  // const { user } = useContext(AuthContext);
  // const isAuthenticated = !!user;


  // useEffect(() => {
    // fetchData();
  // }, []);

  // Data fetch for User-Display in Team.jsx
  // async function fetchData() {
    // try {
      // const response = await axios.get("http://localhost:5000/api/login");
      // const data = response.data;
      // setUsers(data);
    // } catch (error) {
      // console.error("Error fetching data:", error.response ? error.response : error);
      // setMessage("An error occurred while fetching data.");
    // }
  // }

  return (
    <AuthProvider>
      <ColorModeContext.Provider value={colorMode}>
        <ThemeProvider theme={theme}>
          <CssBaseline />
          <div className="app">
            {isAuthenticated && isSidebar && <Sidebar />}
            <main className="content">
              {isAuthenticated && <Topbar />}

              <Routes>
                <Route path="/" element={<Login />} />
                <Route path="/login" element={<Login />} />
                <Route path="/dashboard" element={<PrivateRoute component={Dashboard} accessLevel="Admin" />} />
                <Route path="/availability" element={<PrivateRoute component={Availability} accessLevel="Admin" />} />
                <Route path="/company" element={<PrivateRoute component={Company} accessLevel="Admin" />} />
              </Routes>

            </main>
          </div>
        </ThemeProvider>
      </ColorModeContext.Provider>
    </AuthProvider>
  );
}

export default App;





import React, { useContext, useState } from 'react';
import { Box, Typography, TextField, Button, Alert, useTheme } from '@mui/material';
import Header from "../../components/Header";
import { useNavigate } from 'react-router-dom';
import { tokens } from "../../theme";
import { AuthContext } from "../../AuthContext";


const Login = () => {
  const { login } = useContext(AuthContext);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const navigate = useNavigate();
  const theme = useTheme();
  const colors = tokens(theme.palette.mode);

  const handleFormSubmit = async (e) => {
    e.preventDefault();

    try {
      await login(email, password);
    } catch (error) {
      setError('error.message');
    }
  };

  return (
    <Box
    m="20px"
    justifyContent="center"
    alignItems="center"    
    >
    <Header title="Login" subtitle="" />
      <Box width="300px" p={2}>
        <form onSubmit={handleFormSubmit}>
          <Box mb={2}>
            <TextField
              type="email"
              label="Email"
              fullWidth
              value={email}
              onChange={(e) => setEmail(e.target.value)}
            />
          </Box>
          <Box mb={2}>
            <TextField
              type="password"
              label="Password"
              fullWidth
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
          </Box>
          <Button type="submit" variant="contained" fullWidth>
            Login
          </Button>
          {error && (
            <Box mt={2}>
              <Alert severity="error">{error}</Alert>
            </Box>
          )}
        </form>
      </Box>
    </Box>
  );
};

export default Login;







import { useState, useEffect } from "react";
import { useTheme, Box, Button, TextField, Snackbar, Typography } from "@mui/material";
import { Formik } from "formik";
import * as yup from "yup";
import useMediaQuery from "@mui/material/useMediaQuery";
import Header from "../../components/Header";
import { tokens } from "../../theme";
import axios from 'axios';

const Company = ({ company }) => {
  const theme = useTheme();
  const colors = tokens(theme.palette.mode);
  const isNonMobile = useMediaQuery("(min-width:600px)");
  const [showSuccessNotification, setShowSuccessNotification] = useState(false);
  const [showErrorNotification, setShowErrorNotification] = useState(false);
  const [companyData, setcompanyData] = useState({});
  const [currentUser, setCurrentUser] = useState(null); 

  useEffect(() => {
    const baseURL = 'http://localhost:5000/api'; // Update with your Flask app's base URL
    
    const fetchCompany = async () => {
      try {
        const response = await axios.get('http://localhost:5000/api/company');
        setcompanyData(response.data);
      } catch (error) {
        console.error('Error fetching company details:', error);
      }
    };

    fetchCompany();
  }, []);

  
  const handleFormSubmit = async (values) => {
    try {
      // Send the updated form values to the server for database update
      await axios.post('http://localhost:5000/api/company', values);
      setShowSuccessNotification(true);
    } catch (error) {
      console.error('Error updating company details:', error);
      setShowErrorNotification(true);
    }
  };


  return (
    <Box m="20px">
      <Header
        title="COMPANY"
        subtitle="Please update your company data whenever necessary. These are the basics for your optimized Scheduler."
      />
      <h2>Company Information</h2>

      <Formik
        onSubmit={handleFormSubmit}
        enableReinitialize={true}
        initialValues={{
          company_name: companyData.company_name, // Use companyData values as defaults
          weekly_hours: companyData.weekly_hours,
          shifts: companyData.shifts,
          ...Array.from({ length: companyData.day_num }).reduce((acc, _, rowIndex) => {
            acc[`day_${rowIndex}_0`] = companyData.temp_dict[`${rowIndex + 1}&0`];
            acc[`day_${rowIndex}_1`] = companyData.temp_dict[`${rowIndex + 1}&1`];
            return acc;
          }, {}),
        }}
        validationSchema={checkoutSchema}
      >
        {({
          values,
          errors,
          touched,
          handleBlur,
          handleChange,
          handleSubmit,
        }) => (
          <form onSubmit={handleSubmit}>
            <Box
              display="grid"
              gap="30px"
              gridTemplateColumns="repeat(6, minmax(0, 1fr))"
              sx={{
                "& > div": { gridColumn: isNonMobile ? undefined : "span 6" },
              }}
            >
              <Typography
                color={colors.greenAccent[500]}
                variant="h6"
                sx={{
                  gridColumn: "span 1",
                  display: "flex",
                  alignItems: "right",
                  height: "100%",
                }}
              >
                Firmennamen
              </Typography>
              <TextField
                fullWidth
                variant="filled"
                type="text"
                label= ""
                onBlur={handleBlur}
                onChange={handleChange}
                value={companyData.company_name}
                name="company_name"
                error={!!touched.company_name && !!errors.company_name}
                helperText={touched.company_name && errors.company_name}
                sx={{ gridColumn: "span 1" }}
              />
              <Typography
                color={colors.greenAccent[500]}
                variant=""
                sx={{
                  gridColumn: "span 4",
                  display: "grid",
                  alignItems: "center",
                  height: "100%",
                }}
              ></Typography>
              <Typography
                color={colors.greenAccent[500]}
                variant="h6"
                sx={{
                  gridColumn: "span 1",
                  display: "flex",
                  alignItems: "right",
                  height: "100%",
                }}
              >
                Weekly Hours
              </Typography>
              <TextField
                fullWidth
                variant="filled"
                type="text"
                label= ""
                onBlur={handleBlur}
                onChange={handleChange}
                value={values.weekly_hours}
                name="weekly_hours"
                placeholder={companyData.weekly_hours || ""}
                error={!!touched.weekly_hours && !!errors.weekly_hours}
                helperText={touched.weekly_hours && errors.weekly_hours}
                sx={{ gridColumn: "span 1" }}
              />
              <Typography
                color={colors.greenAccent[500]}
                variant=""
                sx={{
                  gridColumn: "span 4",
                  display: "grid",
                  alignItems: "center",
                  height: "100%",
                }}
              ></Typography>
              <Typography
                color={colors.greenAccent[500]}
                variant="h6"
                sx={{
                  gridColumn: "span 1",
                  display: "flex",
                  alignItems: "right",
                  height: "100%",
                }}
              >
                Shifts
              </Typography>
              <TextField
                fullWidth
                variant="filled"
                type="text"
                label= ""
                onBlur={handleBlur}
                onChange={handleChange}
                value={values.shifts}
                name="shifts"
                error={!!touched.shifts && !!errors.shifts}
                helperText={touched.shifts && errors.shifts}
                sx={{ gridColumn: "span 1" }}
              />
              <Typography
                color={colors.greenAccent[500]}
                variant=""
                sx={{
                  gridColumn: "span 4",
                  display: "grid",
                  alignItems: "center",
                  height: "100%",
                }}
              ></Typography>
            </Box>
            <></>
            <></>
            <h2>Opening Hour of your mother's legs</h2>
            <></>
            <></>
            <Box
              display="grid"
              gap="30px"
              gridTemplateColumns="repeat(6, minmax(0, 1fr))"
              sx={{
                "& > div": { gridColumn: isNonMobile ? undefined : "span 6" },
              }}
            >
              <Typography
                color={colors.greenAccent[500]}
                variant="h6"
                sx={{
                  gridColumn: "span 1",
                  display: "flex",
                  alignItems: "center",
                  height: "100%",
                }}
              >
                Weekday
              </Typography>
              <Typography
                color={colors.greenAccent[500]}
                variant="h6"
                sx={{
                  gridColumn: "span 1",
                  display: "flex",
                  alignItems: "center",
                  height: "100%",
                }}
              >
                Start Time
              </Typography>
              <Typography
                color={colors.greenAccent[500]}
                variant="h6"
                sx={{
                  gridColumn: "span 1",
                  display: "flex",
                  alignItems: "center",
                  height: "100%",
                }}
              >
                End Time
              </Typography>
              <Typography
                color={colors.greenAccent[500]}
                variant=""
                sx={{
                  gridColumn: "span 3",
                  display: "flex",
                  alignItems: "center",
                  height: "100%",
                }}
              ></Typography>
              {Array.from({ length: companyData.day_num }).map((_, rowIndex) => (
              <>
                <Typography
                  key={`number-${rowIndex}`}
                  color={colors.greenAccent[500]}
                  variant=""
                  sx={{
                    gridColumn: "span 1",
                    display: "flex",
                    alignItems: "center",
                    height: "100%",
                  }}
                >
                  {companyData && companyData.weekdays
                    ? companyData.weekdays[rowIndex]
                    : ""}
                  </Typography>
                  <TextField
                    key={`day_${rowIndex}_0`}
                    fullWidth
                    variant="filled"
                    type="time"
                    onBlur={handleBlur}
                    onChange={handleChange}
                    value={values[`day_${rowIndex}_0`]}
                    name={`day_${rowIndex}_0`}
                    error={
                      !!touched[`day_${rowIndex}_0`] &&
                      !!errors[`day_${rowIndex}_0`]
                    }
                    helperText={
                      touched[`day_${rowIndex}_0`] &&
                      errors[`day_${rowIndex}_0`]
                    }
                    sx={{ gridColumn: "span 1" }}
                  />
                  <TextField
                    key={`day_${rowIndex}_1`}
                    fullWidth
                    variant="filled"
                    type="time"
                    onBlur={handleBlur}
                    onChange={handleChange}
                    value={values[`day_${rowIndex}_1`]}
                    name={`day_${rowIndex}_1`}
                    error={
                      !!touched[`day_${rowIndex}_1`] &&
                      !!errors[`day_${rowIndex}_1`]
                    }
                    helperText={
                      touched[`day_${rowIndex}_1`] &&
                      errors[`day_${rowIndex}_1`]
                    }
                    sx={{ gridColumn: "span 1" }}
                  />

                  <Typography
                    key={`empty-1-${rowIndex}`}
                    color={colors.greenAccent[500]}
                    variant=""
                    sx={{
                      gridColumn: "span 3",
                      display: "flex",
                      alignItems: "center",
                      height: "100%",
                    }}
                  ></Typography>
                </>
              ))}
            </Box>
            <Box display="flex" justifyContent="end" mt="20px">
              <Button type="submit" color="secondary" variant="contained">
                Update
              </Button>
            </Box>
          </form>
        )}
      </Formik>
      <Snackbar
        open={showSuccessNotification}
        onClose={() => setShowSuccessNotification(false)}
        message="Registration successful"
        autoHideDuration={3000}
        sx={{
          backgroundColor: "green !important",
          color: "white",
          "& .MuiSnackbarContent-root": {
            borderRadius: "4px",
            padding: "15px",
            fontSize: "16px",
          },
        }}
      />
      <Snackbar
        open={showErrorNotification}
        onClose={() => setShowErrorNotification(false)}
        message="Error occurred - Your shifts might already be in use"
        autoHideDuration={3000}
        sx={{
          backgroundColor: "red !important",
          color: "white",
          "& .MuiSnackbarContent-root": {
            borderRadius: "4px",
            padding: "15px",
            fontSize: "16px",
          },
        }}
      />
    </Box>
  );
};

const checkoutSchema = yup.object().shape({
  company_name: yup.string(),
  weekly_hours: yup.number(),
  shifts: yup.number(),
});

export default Company;







@app.route('/api/login', methods=['POST'])
def login_react():
    email = request.json.get('email')
    password = request.json.get('password')

    user = User.query.filter_by(email=email).first()
    if not user or not check_password_hash(user.password, password):
        return jsonify({'error': 'Invalid email or password'}), 401

    # Generate the JWT token
    additional_claims = {"user_id": user.id}
    session_token = create_access_token(identity=email, additional_claims=additional_claims)

    # Return the session token
    response = make_response(jsonify({'session_token': session_token}))
    response.set_cookie('session_token', session_token, httponly=True, secure=True)

    # Save User Data and token
    response = {
        'session_token': session_token,
        'user': {
            'id': user.id,
            'email': user.email,
            'company_id': user.company_id,
            'first_name': user.first_name,
            'last_name': user.last_name,
            'employment': user.employment,
            'email': user.email,
            'employment_level': user.employment_level,
            'company_name': user.company_name,
            'department': user.department,
            'access_level': user.access_level
        }
    }
    print(response)
    return jsonify(response)


@app.route('/api/users')
def get_data():
    users = User.query.all()
    user_list = []
    for user in users:
        user_dict = {
            'id': user.id,
            'first_name': user.first_name,
            'last_name': user.last_name,
            'company_name': user.company_name,
            'email': user.email,
            'access_level': user.access_level
        }
        user_list.append(user_dict)
    return jsonify(user_list)

@app.route('/api/current_user', methods=['GET'])
def get_current_user():
    current_user = get_jwt_identity()
    user = User.query.filter_by(email=current_user['email']).first()
    
    if user:
        user_data = {
            'id': user.id, 
            'company_id': user.company_id,
            'first_name': user.first_name,
            'last_name': user.last_name,
            'employment': user.employment,
            'email': user.email,
            'employment_level': user.employment_level,
            'company_name': user.company_name,
            'department': user.department,
            'access_level': user.access_level
        }
        print(user_data)
        return user_data
    
    return None


@app.route('/api/new_user', methods=['POST'])
def new_user():
    data = request.json
    user = User(first_name=data['first_name'],
                last_name=data['last_name'],
                email=data['email'],
                employment_level=data['employment_level'],
                company_name=data['company_name'],
                department=data['department'],
                access_level=data['access_level'])
    db.session.add(user)
    db.session.commit()
    return {'success': True}


@app.route('/api/registration/admin', methods=['POST'])
def api_admin_registration():
    data = request.json
    creation_date = datetime.datetime.now()
    last = User.query.order_by(User.id.desc()).first()

    if last is None:
        new_id = 1
    else:
        new_id = last.id + 1

    last_company_id = User.query.filter_by(company_name=data['company_name']).order_by(User.company_id.desc()).first()

    if last_company_id is None:
        new_company_id = 10000
    else:
        new_company_id = last_company_id.company_id + 1

    data = User(
        id=new_id,
        company_id=new_company_id,
        first_name=data['first_name'],
        last_name=data['last_name'],
        employment_level=data['employment_level'],
        employment=data['employment'],
        company_name=data['company_name'],
        department=data['department'],
        access_level=data['access_level'],
        email=data['email'],
        password=generate_password_hash(data['password']),
        created_by=new_company_id,
        changed_by=new_company_id,
        creation_timestamp=creation_date
    )

    try:
        db.session.add(data)
        db.session.commit()
        return jsonify({'message': 'Registration successful'})
    
    except:
        db.session.rollback()
        return jsonify({'error': 'Error occurred - Your email might already be in use'})



@app.route('/api/update', methods=["GET", "POST"])
def react_update():
    new_data = User.query.get(current_user.id)
    user_form = UpdateForm(csrf_enabled=False, obj=new_data)
    company_id = User.query.get(current_user.company_id)

    if request.method == 'POST':
        existing_user = User.query.filter_by(id=current_user.id).first()
        if existing_user:
            existing_user.first_name = user_form.first_name.data
            existing_user.last_name = user_form.last_name.data
            existing_user.employment_level = user_form.employment_level.data
            existing_user.company_name = user_form.company_name.data
            existing_user.department = user_form.department.data
            existing_user.access_level = user_form.access_level.data
            existing_user.email = user_form.email.data
            existing_user.changed_by = company_id
            existing_user.update_timestamp = datetime.datetime.now

            db.session.commit()


    return render_template('update.html', data_tag=User.query.all(), account=new_data, template_form=user_form)

@app.route('/api/company', methods=['GET', 'POST'])
def get_company():
    # This has to be updated to the current user once the function is implemented.
    react_user = get_current_user()
    email = react_user['email']
    print(email)
    user = User.query.filter_by(email=email).first()
    opening_hours = OpeningHours.query.filter_by(company_name=user.company_name).first()
    weekdays = {0:'Monday', 1:'Tuesday', 2:'Wednesday', 3:'Thursday', 4:'Friday', 5:'Saturday', 6:'Sunday'}
    company = Company.query.filter_by(company_name=user.company_name).first()
    day_num = 7
    company_id = user.company_id
    creation_date = datetime.datetime.now()

    if company is None:
        company_name = ''
        shift = ''
        weekly_hour = ''
    else:
        company_name = company.company_name
        shift = company.shifts
        weekly_hour = company.weekly_hours

    temp_dict = {}
    for i in range(day_num):
        temp = OpeningHours.query.filter_by(company_name=user.company_name, weekday=weekdays[i]).first()
        if temp is None:
            pass
        else:
            new_i = i + 1
            temp_dict[str(new_i) + '&0'] = temp.start_time.strftime("%H:%M") if temp.start_time else None
            temp_dict[str(new_i) + '&1'] = temp.end_time.strftime("%H:%M") if temp.end_time else None

        if request.method == 'POST':
            company_data = request.get_json()

            # Company Data 
            OpeningHours.query.filter_by(company_name=user.company_name).delete()
            db.session.commit()
            company_no = Company.query.order_by(Company.id.desc()).first()
            if company_no is None:
                new_company_no = 1
            else:
                new_company_no = company_no.id + 1
            


            company_data = Company(
                id=new_company_no,
                company_name=company_data['company_name'],
                weekly_hours=company_data['weekly_hours'],
                shifts=company_data['shifts'],
                created_by=company_id,
                changed_by=company_id,
                creation_timestamp=creation_date
            )

            db.session.merge(company_data)
            db.session.commit()

            for i in range(day_num):
                entry1 = request.json.get(f'day_{i}_0')
                print(entry1)
                entry2 = request.json.get(f'day_{i}_1')
                if entry1:
                    last = OpeningHours.query.order_by(OpeningHours.id.desc()).first()
                    if last is None:
                        new_id = 1
                    else:
                        new_id = last.id + 1
                    try:
                        new_entry1 = datetime.datetime.strptime(entry1, '%H:%M:%S').time()
                    except:
                        new_entry1 = datetime.datetime.strptime(entry1, '%H:%M').time()

                    try:
                        new_entry2 = datetime.datetime.strptime(entry2, '%H:%M:%S').time()
                    except:
                        new_entry2 = datetime.datetime.strptime(entry2, '%H:%M').time()

                    new_weekday = weekdays[i]

                    opening = OpeningHours(
                    id=new_id,
                    company_name=user.company_name,
                    weekday=new_weekday,
                    start_time=new_entry1,
                    end_time=new_entry2,
                    created_by=company_id,
                    changed_by=company_id,
                    creation_timestamp=creation_date
                )

                db.session.add(opening)
                db.session.commit()


    company_list = {
        'company_name': company_name,
        'shifts': shift,
        'weekly_hours': weekly_hour,
        'weekdays': weekdays,
        'day_num': day_num,
        'temp_dict': temp_dict, 
    }
    
    
    return jsonify(company_list)



@app.route('/api/availability', methods = ['GET', 'POST'])
def get_availability():
    # today's date
    user = User.query.filter_by(email="robin.martin@timetab.ch").first()
    today = datetime.date.today()
    creation_date = datetime.datetime.now()
    monday = today - datetime.timedelta(days=today.weekday())
    weekdays = {0:'Monday', 1:'Tuesday', 2:'Wednesday', 3:'Thursday', 4:'Friday', 5:'Saturday', 6:'Sunday'}
    day_num = 7
    week_adjustment = session.get('week_adjustment', 0)
    company_id = user.company_id
    planning_form = PlanningForm(csrf_enabled = False)

    """
    company_dict = {}
    for company in User.query.filter_by(email=user.email).all():
        company_dict[company.company_name] = company
    """      


    temp_dict = {}
    for i in range(day_num):
        temp = Availability.query.filter_by(email=user.email, weekday=weekdays[i]).first()
        if temp is None:
            pass
        else:
            new_i = i + 1
            temp_dict[str(new_i) + '&0'] = temp.start_time.strftime("%H:%M") if temp.start_time else None
            temp_dict[str(new_i) + '&1'] = temp.end_time.strftime("%H:%M") if temp.end_time else None
            temp_dict[str(new_i) + '&2'] = temp.start_time2.strftime("%H:%M") if temp.start_time else None
            temp_dict[str(new_i) + '&3'] = temp.end_time2.strftime("%H:%M") if temp.end_time else None
            temp_dict[str(new_i) + '&4'] = temp.start_time3.strftime("%H:%M") if temp.start_time else None
            temp_dict[str(new_i) + '&5'] = temp.end_time3.strftime("%H:%M") if temp.end_time else None


    if planning_form.prev_week.data:
        week_adjustment -=7
        session['week_adjustment'] = week_adjustment

        monday = monday + datetime.timedelta(days=week_adjustment)

        return render_template('planning.html', template_form=planning_form, monday=monday, weekdays=weekdays,
                               day_num=day_num)

    if planning_form.next_week.data:
        week_adjustment +=7
        session['week_adjustment'] = week_adjustment

        monday = monday + datetime.timedelta(days=week_adjustment)

        return render_template('planning.html', template_form=planning_form, monday=monday, weekdays=weekdays,
                               day_num=day_num, temp_dict=temp_dict)



    #Save Availability
    if request.method == 'POST':
        availability_data = request.get_json()
        for i in range(day_num):
            new_date = monday + datetime.timedelta(days=i) + datetime.timedelta(days=week_adjustment)
            Availability.query.filter_by(user_id=user.id, date=new_date).delete()
            db.session.commit()

            entry1 = request.json.get(f'day_{i}_0')
            entry2 = request.json.get(f'day_{i}_1')
            entry3 = request.json.get(f'day_{i}_2')
            entry4 = request.json.get(f'day_{i}_3')
            entry5 = request.json.get(f'day_{i}_4')
            entry6 = request.json.get(f'day_{i}_5')
            if entry1:
                last = Availability.query.order_by(Availability.id.desc()).first()
                if last is None:
                    new_id = 1
                else:
                    new_id = last.id + 1
    
                try:
                    new_entry1 = datetime.datetime.strptime(entry1, '%H:%M:%S').time()
                except:
                    new_entry1 = datetime.datetime.strptime(entry1, '%H:%M').time()
                
                try:
                    new_entry2 = datetime.datetime.strptime(entry2, '%H:%M:%S').time()
                except:
                    new_entry2 = datetime.datetime.strptime(entry2, '%H:%M').time()
                
                try:
                    new_entry3 = datetime.datetime.strptime(entry3, '%H:%M:%S').time()
                except:
                    new_entry3 = datetime.datetime.strptime(entry3, '%H:%M').time()
                
                try:
                    new_entry4 = datetime.datetime.strptime(entry4, '%H:%M:%S').time()
                except:
                    new_entry4 = datetime.datetime.strptime(entry4, '%H:%M').time()
               
                try:
                    new_entry5 = datetime.datetime.strptime(entry5, '%H:%M:%S').time()
                except:
                    new_entry5 = datetime.datetime.strptime(entry5, '%H:%M').time()
                
                try:
                    new_entry6 = datetime.datetime.strptime(entry6, '%H:%M:%S').time()
                except:
                    new_entry6 = datetime.datetime.strptime(entry6, '%H:%M').time()

                
                new_weekday = weekdays[i]


                data = Availability(
                    id=new_id, 
                    user_id=user.id, 
                    date=new_date, 
                    weekday=new_weekday, 
                    email=user.email,
                    start_time=new_entry1, 
                    end_time=new_entry2, 
                    start_time2=new_entry3,
                    end_time2=new_entry4, 
                    start_time3=new_entry5, 
                    end_time3=new_entry6,
                    created_by=company_id, 
                    changed_by=company_id, 
                    creation_timestamp = creation_date
                    )


                db.session.add(data)
                db.session.commit()

    #Save templates
    if request.method == 'POST' and 'template' in request.form:
        for i in range(day_num):
            entry1 = request.form.get(f'day_{i}_0')
            entry2 = request.form.get(f'day_{i}_1')
            entry3 = request.form.get(f'day_{i}_2')
            entry4 = request.form.get(f'day_{i}_3')
            entry5 = request.form.get(f'day_{i}_4')
            entry6 = request.form.get(f'day_{i}_5')
            if entry1:
                last = TemplateAvailability.query.order_by(TemplateAvailability.id.desc()).first()
                if last is None:
                    new_id = 1
                else:
                    new_id = last.id + 1
                new_name = planning_form.template_name.data
                new_date = monday + datetime.timedelta(days=i)
                new_entry1 = datetime.datetime.strptime(entry1, '%H:%M').time()
                new_entry2 = datetime.datetime.strptime(entry2, '%H:%M').time()
                new_entry3 = datetime.datetime.strptime(entry3, '%H:%M').time()
                new_entry4 = datetime.datetime.strptime(entry4, '%H:%M').time()
                new_entry5 = datetime.datetime.strptime(entry5, '%H:%M').time()
                new_entry6 = datetime.datetime.strptime(entry6, '%H:%M').time()
                new_weekday = weekdays[i]

                data = TemplateAvailability(
                    id=new_id, 
                    template_name=new_name, 
                    date=new_date, 
                    weekday=new_weekday, 
                    email=user.email,
                    start_time=new_entry1, 
                    end_time=new_entry2, 
                    start_time2=new_entry3,
                    end_time2=new_entry4, 
                    start_time3=new_entry5, 
                    end_time3=new_entry6,
                    created_by=company_id, 
                    changed_by=company_id, 
                    creation_timestamp = creation_date
                    )


                db.session.add(data)
                db.session.commit()

    availability_list = {
        'weekdays': weekdays,
        'day_num': day_num,
        'temp_dict': temp_dict,
    }

    return jsonify(availability_list)

